<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <title>JS动态加载（悬浮窗常驻版）</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; font-family: "Microsoft YaHei", sans-serif; }
        body { height: 100vh; overflow: hidden; position: relative; margin: 0; padding: 0; }
        
        /* 1. 核心：内容容器（仅放动态加载的新HTML，不碰悬浮窗） */
        #dynamicContent { 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
            z-index: 1; /* 层级低于悬浮窗，不遮挡 */
            overflow: auto; /* 新页面内容超出屏幕可滚动，模拟正常页面 */
        }

        /* 2. 悬浮球：常驻顶层，JS动态操作不影响它 */
        .float-btn { 
            position: fixed; z-index: 9999; width: 60px; height: 60px; border-radius: 0; box-shadow: 0 3px 15px rgba(0,0,0,0.3); 
            cursor: pointer; user-select: none; -webkit-tap-highlight-color: transparent; transition: transform 0.2s ease, box-shadow 0.2s ease; 
            background-image: url(https://i.imgs.ovh/2025/09/28/75fraO.jpeg); background-color: #f0f0f0; 
            background-size: cover; background-position: center; background-repeat: no-repeat; 
            padding: 0; margin: 0; border: none; right: 20px; bottom: 50px; 
        }
        .float-btn:active { transform: scale(0.95); box-shadow: 0 5px 20px rgba(0,0,0,0.4); }
        
        /* 3. 悬浮窗：常驻顶层，DOM独立，不被动态内容删除 */
        .float-window { 
            position: fixed; z-index: 9998; width: 300px; height: 280px; background: white; border-radius: 12px; 
            box-shadow: 0 5px 25px rgba(0,0,0,0.15); overflow: hidden; display: none; opacity: 0; transition: opacity 0.3s ease; 
        }
        .float-window.active { display: block; opacity: 1; }
        
        .window-header { 
            padding: 12px 15px; background: linear-gradient(90deg, #2563eb, #3b82f6); color: white; 
            font-size: 16px; font-weight: 500; display: flex; justify-content: space-between; align-items: center; 
            cursor: move; -webkit-tap-highlight-color: transparent; height: 44px; 
        }
        .modal-back { 
            background: transparent; border: none; color: white; font-size: 14px; cursor: pointer; 
            padding: 4px 8px; border-radius: 4px; transition: background 0.2s ease; display: none; -webkit-tap-highlight-color: transparent; 
        }
        .modal-back:hover { background: rgba(255,255,255,0.1); }
        
        .func-buttons { 
            padding: 10px; display: flex; flex-direction: column; gap: 10px; 
            max-height: calc(280px - 44px); overflow-y: auto; -webkit-overflow-scrolling: touch; 
        }
        .func-btn { 
            padding: 12px 15px; border-radius: 8px; background: #f8f9fa; font-size: 14px; color: #333; 
            text-align: left; cursor: pointer; transition: background 0.2s ease, transform 0.1s ease; 
            display: flex; align-items: center; justify-content: space-between; 
            -webkit-tap-highlight-color: transparent; border: none; box-shadow: 0 1px 3px rgba(0,0,0,0.05);
        }
        .func-btn:hover { background: #f1f3f5; transform: translateY(-1px); }
        .btn-icon { width: 20px; height: 20px; opacity: 0.7; }
        
        .content-panel { 
            padding: 15px; max-height: calc(280px - 44px); overflow-y: auto; 
            -webkit-overflow-scrolling: touch; display: none; 
        }
        .content-panel.active { display: block; }
        
        /* 更新模块样式：核心元素保留，样式隔离 */
        .notice-item { padding: 10px 0; display: block; }
        .notice-title { font-size: 18px; font-weight: 600; color: #2563eb; margin-bottom: 8px; }
        .notice-time { font-size: 12px; color: #999; margin-bottom: 10px; }
        .progress-actions { display: flex; align-items: center; gap: 10px; }
        .download-progress { flex: 1; height: 6px; background: #ebf2ff; border-radius: 3px; overflow: hidden; }
        .progress-bar { height: 100%; background: #2563eb; border-radius: 3px; width: 0%; transition: width 0.03s linear; }
        .action-btn { padding: 6px 12px; border: none; border-radius: 4px; font-size: 12px; cursor: pointer; transition: background 0.2s ease; white-space: nowrap; }
        .download-btn { background: #2563eb; color: white; box-shadow: 0 1px 3px rgba(37, 99, 235, 0.2); }
        .download-btn:disabled { background: #93c5fd; cursor: not-allowed; }
        .update-btn { background: #10b981; color: white; box-shadow: 0 1px 3px rgba(16, 185, 129, 0.2); display: block; }
        .empty-tip { text-align: center; color: #999; font-size: 14px; line-height: 1.5; padding: 20px 0; border: none; background: transparent; }

        /* 新页面样式隔离提示：建议新HTML样式加前缀，避免冲突 */
        #dynamicContent * { box-sizing: border-box; }
    </style>
</head>
<body>
    <!-- 1. 动态内容容器：所有新HTML都动态插入这里，不影响其他DOM -->
    <div id="dynamicContent"></div>

    <!-- 2. 悬浮球：DOM独立，常驻页面 -->
    <button class="float-btn" id="floatBtn"></button>

    <!-- 3. 悬浮窗：DOM独立，功能完整 -->
    <div class="float-window" id="floatWindow">
        <div class="window-header" id="windowHeader">
            功能面板
            <button class="modal-back" id="modalBack">返回</button>
        </div>
        <div class="func-buttons" id="funcButtons">
            <button class="func-btn" id="btnMy">
                <span>我的</span>
                <img src="https://img.icons8.com/ios-glyphs/30/666/user--v1.png" class="btn-icon" alt="我的">
            </button>
            <button class="func-btn" id="btnNotice">
                <span>公告更新</span>
                <img src="https://img.icons8.com/ios-glyphs/30/666/announcement--v1.png" class="btn-icon" alt="公告更新">
            </button>
            <button class="func-btn" id="btnContact">
                <span>联系作者</span>
                <img src="https://img.icons8.com/ios-glyphs/30/666/contact-card--v1.png" class="btn-icon" alt="联系作者">
            </button>
            <button class="func-btn" id="btnSetting">
                <span>设置</span>
                <img src="https://img.icons8.com/ios-glyphs/30/666/settings--v1.png" class="btn-icon" alt="设置">
            </button>
        </div>
        <div class="content-panel" id="panelNotice">
            <div id="noticeContainer">
                <div class="empty-tip" id="defaultTip">加载更新信息中...</div>
                <div class="notice-item" id="pushNotice"></div>
            </div>
        </div>
        <div class="content-panel" id="panelMy">
            <div class="user-name">用一生找寻</div>
            <div class="user-desc">当前功能待开发，暂显示用户名</div>
        </div>
        <div class="content-panel" id="panelContact">
            <div class="empty-tip">点击下方链接联系作者<br><a href="https://qzone.qq.com/2673976185" target="_blank" style="color: #2563eb; text-decoration: none;">前往作者QQ空间</a></div>
        </div>
        <div class="content-panel" id="panelSetting">
            <div class="empty-tip">设置功能待开发</div>
        </div>
    </div>

    <script>
        (function() {
            if (window.floatingWindowInjected) return;
            window.floatingWindowInjected = true;

            // 配置项：替换为你的服务信息
            const config = { 
                domain: "cxk-z875", // Render服务名
                latestNoticeKey: "latestReceivedNotice", // 存储更新信息
                downloadedFileKey: "downloadedFileStatus", // 存储下载状态（永久）
                initHtmlContent: `<!-- 初始页面内容（可替换为你的首页HTML） -->
                    <div style="padding: 20px; text-align: center;">
                        <h1>初始首页</h1>
                        <p style="margin: 20px 0;">点击右下角悬浮窗检查更新</p>
                        <button style="padding: 8px 16px; background: #2563eb; color: white; border: none; border-radius: 4px; cursor: pointer;" onclick="alert('初始页面按钮正常工作')">测试初始页面功能</button>
                    </div>`
            };

            // 工具函数：核心功能保留，全局可用
            const utils = {
                // 边界校验（悬浮窗拖拽用）
                checkWindowBound(left, top) { 
                    const w = document.documentElement.clientWidth; 
                    const h = document.documentElement.clientHeight; 
                    return { 
                        left: Math.max(20, Math.min(left, w - 300 - 20)), 
                        top: Math.max(20, Math.min(top, h - 280 - 20)) 
                    }; 
                },
                // 时间格式化
                formatTime(dateStr) {
                    const date = new Date(dateStr);
                    return `${date.getFullYear()}年${String(date.getMonth() + 1).padStart(2, '0')}月${String(date.getDate()).padStart(2, '0')}日`;
                },
                // 本地存储操作（更新信息+下载状态）
                getStorage(key) { return localStorage.getItem(key) ? JSON.parse(localStorage.getItem(key)) : null; },
                setStorage(key, data) { localStorage.setItem(key, JSON.stringify(data)); },
                // 文件哈希校验（确保新文件精准识别）
                async calculateFileHash(content) {
                    const encoder = new TextEncoder();
                    const hashBuffer = await crypto.subtle.digest('SHA-256', encoder.encode(content));
                    return Array.from(new Uint8Array(hashBuffer)).map(b => b.toString(16).padStart(2, '0')).join('');
                },
                // 检查文件是否已下载（永久生效，新文件才重置）
                isFileDownloaded(fileName, fileHash) {
                    const status = this.getStorage(config.downloadedFileKey);
                    return status && status.name === fileName && status.hash === fileHash;
                }
            };

            // DOM元素：核心分两类，互不干扰
            const dynamicContent = document.getElementById('dynamicContent'); // 动态内容容器
            const floatBtn = document.getElementById('floatBtn');
            const floatWindow = document.getElementById('floatWindow');
            const modalBack = document.getElementById('modalBack');
            const funcButtons = document.getElementById('funcButtons');
            const btnNotice = document.getElementById('btnNotice');
            const panelNotice = document.getElementById('panelNotice');
            const defaultTip = document.getElementById('defaultTip');
            const pushNotice = document.getElementById('pushNotice');

            // 全局状态：不受动态内容影响
            let currentWindowPos = utils.checkWindowBound((window.innerWidth-300)/2, (window.innerHeight-280)/2);
            let currentNoticeData = utils.getStorage(config.latestNoticeKey) || null;
            let btnIsDragging = false, winIsDragging = false;
            let btnDragStart = null, winDragStart = null;
            let downloadInterval = null;

            // 1. 初始化：加载初始页面（纯JS动态插入）
            function initDefaultPage() {
                if (config.initHtmlContent) {
                    renderDynamicHtml(config.initHtmlContent);
                }
            }

            // 2. 核心方法：纯JS动态渲染新HTML（关键！不碰悬浮窗DOM）
            function renderDynamicHtml(htmlContent) {
                if (!htmlContent) return;

                // 步骤1：清空旧内容（只清动态容器，悬浮窗不动）
                dynamicContent.innerHTML = '';

                // 步骤2：创建临时容器，解析HTML结构
                const tempDiv = document.createElement('div');
                tempDiv.innerHTML = htmlContent;

                // 步骤3：提取并插入样式（确保新页面样式生效）
                const styles = tempDiv.querySelectorAll('style');
                styles.forEach(style => {
                    dynamicContent.appendChild(style.cloneNode(true));
                });

                // 步骤4：提取并插入页面结构（body内容）
                const bodyContent = tempDiv.querySelector('body')?.innerHTML || tempDiv.innerHTML;
                const contentWrapper = document.createElement('div');
                contentWrapper.innerHTML = bodyContent;
                dynamicContent.appendChild(contentWrapper);

                // 步骤5：提取并执行脚本（确保新页面JS功能正常）
                const scripts = tempDiv.querySelectorAll('script');
                scripts.forEach(oldScript => {
                    const newScript = document.createElement('script');
                    // 复制脚本属性（src/text）
                    if (oldScript.src) newScript.src = oldScript.src;
                    if (oldScript.textContent) newScript.textContent = oldScript.textContent;
                    // 脚本加载/执行完成后插入（避免顺序问题）
                    newScript.onload = newScript.onreadystatechange = function() {
                        if (!this.readyState || this.readyState === 'loaded' || this.readyState === 'complete') {
                            dynamicContent.appendChild(newScript);
                        }
                    };
                    // 无src的脚本直接插入
                    if (!oldScript.src) dynamicContent.appendChild(newScript);
                });

                // 提示：新页面样式建议加前缀（如#dynamicContent .new-page-xxx），避免和悬浮窗冲突
            }

            // 3. WebSocket：全局常驻，实时接收新更新
            let ws;
            const RECONNECT_DELAY = 1000;
            function initWebSocket() {
                if (ws) ws.close();
                ws = new WebSocket(`wss://${config.domain}.onrender.com`);

                ws.onopen = () => {
                    console.log('WebSocket连接成功');
                    fetchLatestNotice(); // 拉取最新更新
                };

                ws.onclose = () => {
                    console.log('WebSocket断开，自动重连');
                    setTimeout(initWebSocket, RECONNECT_DELAY);
                };

                ws.onmessage = async (e) => {
                    try {
                        const newData = JSON.parse(e.data);
                        if (newData.type === 'notice' && newData.file?.content) {
                            // 哈希校验：仅新文件才更新状态
                            const fileHash = await utils.calculateFileHash(newData.file.content);
                            newData.file.hash = fileHash;
                            const isNewFile = !utils.isFileDownloaded(newData.file.name, fileHash);

                            if (isNewFile) {
                                currentNoticeData = newData;
                                utils.setStorage(config.latestNoticeKey, newData);
                                renderUpdatePanel();
                                notifyNewUpdate();
                            }
                        }
                    } catch (err) {
                        console.error('解析更新失败：', err);
                    }
                };
            }

            // 4. 拉取最新更新（兜底：WebSocket断开时用）
            async function fetchLatestNotice() {
                try {
                    const res = await fetch(`https://${config.domain}.onrender.com/getLatestAnnouncement`);
                    if (!res.ok) throw new Error(`请求失败（${res.status}）`);

                    const result = await res.json();
                    if (result.success && result.data?.file?.content) {
                        const fileHash = await utils.calculateFileHash(result.data.file.content);
                        result.data.file.hash = fileHash;
                        const isNewFile = !utils.isFileDownloaded(result.data.file.name, fileHash);

                        if (isNewFile) {
                            currentNoticeData = result.data;
                            utils.setStorage(config.latestNoticeKey, result.data);
                        }
                        renderUpdatePanel();
                    } else {
                        defaultTip.textContent = '暂无更新';
                    }
                } catch (err) {
                    console.error('拉取更新失败：', err);
                    defaultTip.textContent = '加载更新失败，稍后重试';
                    setTimeout(fetchLatestNotice, 10000);
                }
            }

            // 5. 渲染更新面板（下载/更新按钮状态）
            function renderUpdatePanel() {
                if (!currentNoticeData?.file) {
                    defaultTip.style.display = 'block';
                    pushNotice.style.display = 'none';
                    return;
                }

                const { name: fileName, hash } = currentNoticeData.file;
                const isDownloaded = utils.isFileDownloaded(fileName, hash);

                // 渲染核心元素：更新标题、时间、进度条、按钮
                pushNotice.innerHTML = `
                    <div class="notice-title">更新</div>
                    <div class="notice-time">更新时间：${utils.formatTime(currentNoticeData.date || new Date())}</div>
                    <div class="progress-actions">
                        <div class="download-progress" id="downloadProgress">
                            <div class="progress-bar" id="progressBar"></div>
                        </div>
                        <button class="action-btn ${isDownloaded ? 'update-btn' : 'download-btn'}" 
                                id="downloadBtn" 
                                onclick="${isDownloaded ? 'handleUpdate()' : 'handleDownload()'}">
                            ${isDownloaded ? '更新' : '下载'}
                        </button>
                    </div>
                `;

                defaultTip.style.display = 'none';
                pushNotice.style.display = 'block';
            }

            // 6. 下载逻辑：纯JS控制，完成后永久变“更新”
            window.handleDownload = function() {
                const progressBar = document.getElementById('progressBar');
                const downloadBtn = document.getElementById('downloadBtn');
                const { name: fileName, content, hash } = currentNoticeData.file;

                if (!progressBar || !downloadBtn || !content) return;

                // 清除旧定时器，避免卡住
                if (downloadInterval) clearInterval(downloadInterval);

                // 下载中状态
                downloadBtn.textContent = '下载中';
                downloadBtn.disabled = true;
                progressBar.style.width = '0%';

                // 模拟进度（实际可替换为真实下载进度）
                let progress = 0;
                downloadInterval = setInterval(() => {
                    progress += 5;
                    progressBar.style.width = `${progress}%`;

                    if (progress >= 100) {
                        clearInterval(downloadInterval);
                        // 永久切换为“更新”按钮
                        downloadBtn.textContent = '更新';
                        downloadBtn.className = 'action-btn update-btn';
                        downloadBtn.onclick = handleUpdate;
                        downloadBtn.disabled = false;
                        // 标记已下载（localStorage永久存储）
                        utils.setStorage(config.downloadedFileKey, {
                            name: fileName,
                            hash: hash,
                            time: Date.now()
                        });
                    }
                }, 100);
            };

            // 7. 更新逻辑：纯JS动态加载新HTML（不删悬浮窗）
            window.handleUpdate = function() {
                if (!confirm('确认更新？更新后加载最新页面，悬浮窗可正常使用')) return;

                try {
                    const { content: newHtmlContent } = currentNoticeData.file;
                    if (!newHtmlContent) throw new Error('无最新页面内容');

                    // 关键：调用动态渲染方法，只更内容容器
                    renderDynamicHtml(newHtmlContent);
                    alert('更新成功！新页面功能正常，悬浮窗可随时使用');
                } catch (err) {
                    alert(`更新失败：${err.message}`);
                }
            };

            // 8. 悬浮窗辅助功能：提示、拖拽、面板切换
            function notifyNewUpdate() {
                // 系统通知
                if (Notification.permission === 'granted') {
                    new Notification('收到新更新', {
                        body: `更新时间：${utils.formatTime(currentNoticeData.date)}`,
                        icon: 'https://img.icons8.com/ios-glyphs/30/2563eb/announcement--v1.png'
                    });
                } else if (Notification.permission !== 'denied') {
                    Notification.requestPermission().then(perm => {
                        if (perm === 'granted') notifyNewUpdate();
                    });
                }

                // 弹窗提示+展开悬浮窗
                alert('收到新更新！点击悬浮窗查看');
                floatWindow.classList.add('active');
                floatWindow.style.left = `${currentWindowPos.left}px`;
                floatWindow.style.top = `${currentWindowPos.top}px`;
                renderUpdatePanel();
            }

            // 面板切换
            function switchPanel(targetId) {
                document.querySelectorAll('.content-panel').forEach(panel => {
                    panel.classList.remove('active');
                    panel.style.display = 'none';
                });
                document.getElementById(targetId).classList.add('active');
                document.getElementById(targetId).style.display = 'block';
                modalBack.style.display = 'block';
            }

            // 悬浮球拖拽
            floatBtn.addEventListener('touchstart', (e) => {
                const touch = e.touches[0];
                btnDragStart = { x: touch.clientX, y: touch.clientY, rect: floatBtn.getBoundingClientRect() };
                btnIsDragging = false;
            }, { passive: true });

            floatBtn.addEventListener('touchmove', (e) => {
                const touch = e.touches[0];
                const dx = touch.clientX - btnDragStart.x;
                const dy = touch.clientY - btnDragStart.y;
                if (Math.abs(dx) > 5 || Math.abs(dy) > 5) {
                    btnIsDragging = true;
                    const newLeft = btnDragStart.rect.left + dx;
                    const newTop = btnDragStart.rect.top + dy;
                    // 边界限制
                    floatBtn.style.left = `${Math.max(20, Math.min(newLeft, window.innerWidth - 80))}px`;
                    floatBtn.style.top = `${Math.max(20, Math.min(newTop, window.innerHeight - 80))}px`;
                }
            }, { passive: false });

            // 悬浮球点击（展开/收起）
            floatBtn.addEventListener('click', () => {
                if (btnIsDragging) return;
                floatWindow.classList.toggle('active');
                if (floatWindow.classList.contains('active')) {
                    floatWindow.style.left = `${currentWindowPos.left}px`;
                    floatWindow.style.top = `${currentWindowPos.top}px`;
                    renderUpdatePanel();
                }
            });

            // 悬浮窗拖拽
            document.getElementById('windowHeader').addEventListener('touchstart', (e) => {
                if (!floatWindow.classList.contains('active')) return;
                const touch = e.touches[0];
                winDragStart = { x: touch.clientX, y: touch.clientY, rect: floatWindow.getBoundingClientRect() };
                winIsDragging = false;
            }, { passive: true });

            document.getElementById('windowHeader').addEventListener('touchmove', (e) => {
                if (!floatWindow.classList.contains('active')) return;
                const touch = e.touches[0];
                const dx = touch.clientX - winDragStart.x;
                const dy = touch.clientY - winDragStart.y;
                if (Math.abs(dx) > 5 || Math.abs(dy) > 5) {
                    winIsDragging = true;
                    currentWindowPos = utils.checkWindowBound(winDragStart.rect.left + dx, winDragStart.rect.top + dy);
                    floatWindow.style.left = `${currentWindowPos.left}px`;
                    floatWindow.style.top = `${currentWindowPos.top}px`;
                }
            }, { passive: false });

            // 面板按钮事件
            modalBack.addEventListener('click', () => {
                document.querySelectorAll('.content-panel').forEach(panel => {
                    panel.classList.remove('active');
                    panel.style.display = 'none';
                });
                funcButtons.style.display = 'flex';
                modalBack.style.display = 'none';
            });
            btnNotice.addEventListener('click', () => {
                funcButtons.style.display = 'none';
                switchPanel('panelNotice');
            });
            document.getElementById('btnMy').addEventListener('click', () => {
                funcButtons.style.display = 'none';
                switchPanel('panelMy');
            });
            document.getElementById('btnContact').addEventListener('click', () => {
                funcButtons.style.display = 'none';
                switchPanel('panelContact');
            });
            document.getElementById('btnSetting').addEventListener('click', () => {
                funcButtons.style.display = 'none';
                switchPanel('panelSetting');
            });

            // 窗口 resize 适配
            window.addEventListener('resize', () => {
                if (floatWindow.classList.contains('active')) {
                    currentWindowPos = utils.checkWindowBound(currentWindowPos.left, currentWindowPos.top);
                    floatWindow.style.left = `${currentWindowPos.left}px`;
                    floatWindow.style.top = `${currentWindowPos.top}px`;
                }
            });

            // 启动流程：先加载初始页面，再启动WebSocket
            document.addEventListener('DOMContentLoaded', () => {
                initDefaultPage();
                initWebSocket();
                fetchLatestNotice();
            });
        })();
    </script>
</body>
</html>
